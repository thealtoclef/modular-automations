name: ðŸš€ Release Docker Image
on:
  workflow_call:
    inputs:
      runs_on:
        description: The runner to use for the job
        default: "self-hosted"
        required: false
        type: string
      platforms:
        description: The platforms to build the Docker image for
        default: "linux/amd64"
        required: false
        type: string
      context_dir:
        description: The context directory to build the Docker image in
        default: "."
        required: false
        type: string
      dockerfile_path:
        description: The path to the Dockerfile to build, relative to the context directory
        default: "Dockerfile"
        required: false
        type: string
      build_args:
        description: Build arguments to pass to the Docker build
        default: ""
        required: false
        type: string
      force_build:
        description: Force build even if no Dockerfile changes detected
        default: false
        required: false
        type: boolean

jobs:
  setup:
    runs-on: ${{ inputs.runs_on }}
    outputs:
      context_dirs: ${{ steps.app-meta.outputs.context_dirs }}
      dockerfile_paths: ${{ steps.app-meta.outputs.dockerfile_paths }}
      image_names: ${{ steps.app-meta.outputs.image_names }}
      destinations: ${{ steps.docker-meta.outputs.tags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get all changed version files
        id: changed-files
        uses: tj-actions/changed-files@v45
        with:
          files: |
            **/version.txt

      - name: Get App metadata
        id: app-meta
        run: |
          # Initialize arrays for outputs
          context_dirs=()
          dockerfile_paths=()
          image_names=()
          versions=()
          descriptions=()

          if [[ "${{ steps.changed-files.outputs.all_changed_files_count }}" -gt "0" || "${{ inputs.force_build }}" == "true" ]]; then
            if [[ "${{ steps.changed-files.outputs.all_changed_files_count }}" -gt "0" ]]; then
              # Process changed version files
              while IFS= read -r changed_file; do
                if [[ -n "${changed_file}" ]]; then
                  context_dir=$(dirname $changed_file)
                  dockerfile_path="Dockerfile"  # Assuming Dockerfile is in the same directory
                  
                  # If version.txt is in root, use repo name as app_name
                  if [[ "$context_dir" == "." ]]; then
                    app_name="${{ github.event.repository.name }}"
                  else
                    app_name=$(basename $context_dir)
                  fi
                  
                  # Only process if Dockerfile exists
                  if [[ -f "$context_dir/Dockerfile" ]]; then
                    # Read version from version.txt
                    version=$(cat "$changed_file")
                    tag_name="${app_name}-${version}"
                    
                    # Check if tag already exists
                    if [ $(git tag -l ${tag_name}) ]; then
                      echo "Tag ${tag_name} already exists, skipping image ${app_name}"
                      continue
                    fi
                    
                    context_dirs+=("$context_dir")
                    dockerfile_paths+=("$dockerfile_path")
                    image_names+=("${{ github.event.repository.owner.login }}/$app_name")
                    versions+=("$version")
                    descriptions+=("Docker image for ${app_name} version ${version}")
                  fi
                fi
              done <<< "${{ steps.changed-files.outputs.all_changed_files }}"
            else
              # Force build with input parameters
              context_dirs+=("${{ inputs.context_dir }}")
              dockerfile_paths+=("${{ inputs.dockerfile_path }}")
              image_names+=("${{ github.event.repository.owner.login }}/${{ github.event.repository.name }}")
              versions+=("latest")  # Default to latest for force builds
              descriptions+=("Docker image for ${{ github.event.repository.name }}")
            fi
          else
            # No changes and no force build
            echo "No changes detected and force_build is false"
            exit 0
          fi

          # Convert arrays to JSON
          context_dirs_json=$(printf '%s\n' "${context_dirs[@]}" | jq -R . | jq -s .)
          dockerfile_paths_json=$(printf '%s\n' "${dockerfile_paths[@]}" | jq -R . | jq -s .)
          image_names_json=$(printf '%s\n' "${image_names[@]}" | jq -R . | jq -s .)
          versions_json=$(printf '%s\n' "${versions[@]}" | jq -R . | jq -s .)
          descriptions_json=$(printf '%s\n' "${descriptions[@]}" | jq -R . | jq -s .)

          echo "context_dirs=${context_dirs_json}" >> $GITHUB_OUTPUT
          echo "dockerfile_paths=${dockerfile_paths_json}" >> $GITHUB_OUTPUT
          echo "image_names=${image_names_json}" >> $GITHUB_OUTPUT
          echo "versions=${versions_json}" >> $GITHUB_OUTPUT
          echo "descriptions=${descriptions_json}" >> $GITHUB_OUTPUT

      - name: Get Docker metadata
        id: docker-meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ fromJson(steps.app-meta.outputs.image_names) }}
          tags: |
            type=sha,format=long,priority=1001,prefix=sha-,enable=true
            type=schedule,pattern=nightly,enable=true,priority=1000
            type=semver,pattern={{version}},value=,enable=true,priority=900
            type=semver,pattern={{major}}.{{minor}},value=,enable=true,priority=900
            type=semver,pattern={{major}},value=,enable=true,priority=900
            type=ref,event=branch,enable=true,priority=600
            type=ref,event=pr,prefix=pr-,enable=true,priority=600
            type=raw,value=latest,enable={{is_default_branch}},priority=200
            type=sha,prefix=sha-,format=short,enable=true,priority=100

  release:
    runs-on: ${{ inputs.runs_on }}
    needs: [setup]
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        index: ${{ fromJson(format('[{0}]', join(range(fromJson(needs.setup.outputs.context_dirs) | length), ','))) }}
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: ${{ inputs.runs_on != 'ubuntu-latest' && 'remote' || '' }}
          endpoint: ${{ inputs.runs_on != 'ubuntu-latest' && 'tcp://buildkit-buildkit-service:1234' || '' }}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: ${{ github.event_name != 'pull_request' }}
          context: "{{defaultContext}}:${{ fromJson(needs.setup.outputs.context_dirs)[matrix.index] }}"
          file: ${{ fromJson(needs.setup.outputs.dockerfile_paths)[matrix.index] }}
          build-args: ${{ inputs.build_args }}
          cache-from: "type=registry,ref=ghcr.io/${{ fromJson(needs.setup.outputs.image_names)[matrix.index] }}:cache"
          cache-to: "mode=max,image-manifest=true,oci-mediatypes=true,type=registry,ref=ghcr.io/${{ fromJson(needs.setup.outputs.image_names)[matrix.index] }}:cache"
          tags: ${{ needs.setup.outputs.destinations }}
          platforms: ${{ inputs.platforms }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2.1.0
        with:
          tag_name: ${{ fromJson(needs.setup.outputs.image_names)[matrix.index] }}-${{ fromJson(needs.setup.outputs.versions)[matrix.index] }}
          body: |
            ${{ fromJson(needs.setup.outputs.descriptions)[matrix.index] }}

            Source commit: https://github.com/${{ github.repository }}/commit/${{ github.sha }}
